       so what is it actually?
= programming pattern or paradigm in js is like the style or mindset for writing code.
it guide the coder or programmer about how should they write , structure and think about the programming task.
js is unique because it is multi paradigm 
       why should you care about it ?
= well to be honest if you are not dumb then choosing a right paradigm before coding would make your code easier to read, maintain and scale.
       classification ? 
1. Imperative Paradigm
Procedural Programming
Structured Programming

2. Declarative Paradigm
Functional Programming 
Reactive Programming (e.g., RxJS)

3. Object-Oriented Programming
Class-based
Prototype-based

4. Event-Driven Programming
Based on event listeners, callbacks, DOM events, etc.

5. Asynchronous Programming (cross-paradigm)
Callback-based
Promise-based
async/await (syntactic sugar over Promises)

1. IMPERATIVE PARADIGM  =very common
=it tells the computer "how to do it" not "what to do"
=it focuses on how a program operates
=here you give step by step instructions
1.A. PROCEDURAL PROGRAMMING
==organizes code into procedures(functions) that operate on data
==follows  a top-down approach
==emphasizes code reusability and modularity
==use it when the task are sequential and can be broken into  steps
==avoid when dealing with complex data relationships or when scalibility is concern
1.B. STRUCTURED PROGRAMMING 
==focuses on control structures like loops, conditionals, functions
==avoids "go to " statements 
==easier to debug and maintain
==use it when writing logic-heavy, algoritm code
==avoid when working in high level framework wherre other patterns fits better


2.DECLARATIVE PROGRAMMING =very common
=focuses on "what to do" not "how to do"
=here you describe the desired outcome and the system handlles the control flow
2.A. FUNCTIONAL PROGRAMMING
==treats computation as evaluation of pure functions
==avoids shared state and side effects
==use higher order functions, map/filter/reduce, immutability and composition
==use it when building pridictable , testable and parallelizable code
==avoid when doing heavy reliance on mutable states or dom manipulation
2.B. REACTIVE PROGRAMMING
==focuses on data streams and propagation of change
==values change over time amnd you react to those changes
==commonly used in RxJS, angular or frontend data binding systems
==use it when dealing with asysnchronous data like use inputs, api streams, websockets etc
==avoid when projects does not require dynamic real time updates


3.OBJECT ORIENTED PROGRAMMING =widely used
=oops is based on objects that combine data(properties) and behaviour(methods)
=it emphasizes encapsulation, inheritance and polymorphism
3.A. CLASS BASED OOP
==introduced in ES6
==defines objects using classes and constructors
==use it when designing large, scalable systems with reusable components
==avoid when writing small scripts or one time logic blocks
3.B. PROTOTYPE BASED OOP
==js original oop model before es6 classes
==objects inherit directly from other objects via prototypes
==use it when you want fine grained control of inheritance
==avoid when the readability or maintainability are key


4.EVENT DRIVEN PROGRAMMING =core in js
=execution flow depends on events
=functions (Callbacks or listeners) are triggered when specific events occur
=use it when building interactive UIs, servers or iot systems
=avoid when logic does not rely on external triggers


5.ASYNCHRONOUS PROGRAMMING (cross paradigm) =
=handles non blocking operations
=allows code execution to continue while waiting for an operation (like api calls, file reading) to complete
5.A. CALLBACK BASED
==use functions passes as arguments to handle results
==can lead to callback hell
5.B. PROMISE BASED
==cleaner way to handle async operations
==avoids deeply nested callbacks
5.C. ASYNC/AWAIT
==syntatic sugar over promises
==makes async code look synchronous
use  it when working with I/O, api calls, file systems or use triggered async operations
avoid when dealing with simple sequential logic due to unnecessary overhead
 

SUMMATIONS
| Scenario                      | Best Paradigm            |
| ----------------------------- | ------------------------ |
| Building reusable components  | Class-based OOP          |
| Handling live data or streams | Reactive Programming     |
| API calls / Background tasks  | Asynchronous Programming |
| Clean, predictable logic      | Functional Programming   |
| Small utilities or scripts    | Procedural Programming   |
| Real-time event-driven apps   | Event-Driven Programming |

| Rank | Paradigm                 | Typical Use in Industry                                    |
| ---- | ------------------------ | ---------------------------------------------------------- |
| 1️⃣  | Procedural Programming   | Low-level scripting, simple algorithms                     |
| 2️⃣  | Structured Programming   | Core logic and control flow design                         |
| 3️⃣  | Prototype-based OOP      | Legacy JS code, advanced framework internals               |
| 4️⃣  | Class-based OOP          | Component-based frameworks (React classes, Node modules)   |
| 5️⃣  | Functional Programming   | Data transformation, React hooks, state management         |
| 6️⃣  | Asynchronous Programming | Web APIs, backend servers, microservices                   |
| 7️⃣  | Event-Driven Programming | UI, Node.js, IoT systems                                   |
| 8️⃣  | Reactive Programming     | Advanced frontends (RxJS, Angular, React with Observables) |

| Paradigm            | Common Stack/Library                             | Example Use                       | Why It Fits                        |
| ------------------- | ------------------------------------------------ | --------------------------------- | ---------------------------------- |
| Procedural          | Vanilla JS                                       | Simple DOM tasks                  | Sequential logic, easy to debug    |
| Structured          | Node.js CLI Tools                                | Data processing scripts           | Uses clear control structures      |
| Class-based OOP     | React (Class Components), TypeScript, Express.js | Modular components                | Code reuse, abstraction            |
| Prototype-based OOP | Pure JS objects, low-level libraries             | Custom inheritance systems        | JS’s native inheritance model      |
| Functional          | React Hooks, Redux, Lodash                       | Pure functions, data immutability | Predictable & testable             |
| Event-Driven        | Node.js, DOM, WebSocket                          | UI events, real-time servers      | Handles multiple concurrent events |
| Reactive            | RxJS, Angular, MobX                              | Live data, async streams          | Reactive data flow                 |
| Asynchronous        | Fetch API, Node.js, async/await                  | APIs, file systems, networking    | Non-blocking performance           |








