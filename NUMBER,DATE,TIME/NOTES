================================================NUMBERS=============================================
=> unlike many other languages js has only one number type:Number
=> which means no separate types for intergers or floats remember it
=> so in js numbers represent both integer and floating point values
=> numbers is technically  a constructor function(built in function) in js
=> numbers are a primitive data type

Characteristics: 
>all numbers in js are stored as 64 bit floating point values as per IEEE 754 standard
>(approximately âˆ’9,007,199,254,740,991 to +9,007,199,254,740,991) range
>no distinction between integers and floats, all are floating point
>special values NaN(not a number), +infinity, -infinity

Number representation like decimal, hexadecimal, binary, octal, scientific notation

Types of numberic values: 
1. interger = whole numbers like 10
2. floating point = decimal numbers like 10.5
3. infinity = larger than any other number like infinity, -infinity
4. NaN = result of invalid numeric opertions like 0/0, parseInt("abc")

There are two ways to use numbers:
1.Primitive type
  let num = 100; and like this for other number representation
2.Number object (constuctor type)
  syntax: new Number(value) here any value to convert to number (string, boolean, etc) default to 0.
  new Number() creats an object, not a primitive number.AND this can lead to confusing bugs and unexpected hehavior.
  let numobj = new Number(100);
Note::avoid new Number() for primitives; use literals for better performance.
3.Number function 
  Syntax: let num = Number(123);

Properties of Numbers, Static properties(constants) : these are read only properties on Number itself.
1. Number.MAX_VALUE = largest representable number  1.7976931348623157e+308
2. Number.MIN_VALUE = smallest positive representable number  5e-324
3. Number.POSITIVE_INFINITY = positive infinity
4. Number.NEGATIVE_INFINITY = negative infinity
5. Number.NaN = non a number constant
6. Number.MAX_SAFE_INTEGER = maximum safe integer  9007199254740991
7. Number.MIN_SAFE_INTEGER = minimum safe integer  -9007199254740991
8. Number.EPSILON = smallest interval between two representable numbers around

Methods of Numbers, Static methods(numbers.method) : these are utility functions on numbers for type checking and conversion.
1. Number.isFinite(value) checks if value  is a finite number and not inifinity or NaN
2. Number.isInteger(value) checks if value is an integer
3. Number.isNaN(value) checks if value is NaN(strict means it does not coerce)
4. Number.isSafeInteger(value) checks if integer is within safe range
5. Number.parseInt(string) converts a string to an integer
6. Number.parseFloat(string) converts a string to a floating point number
remember Number.parseInt and Number.parseFloat are the same as global parseInt() and parseFloat()

Instance properties: 
constructor: reference the Number constructor function 
 == every js object has a constructor property that reference the function that created the instance prototype
[[Prototype]]: points to Number.prototype(internal; not directly accessible)

numberInstance methods/prototype methods: these are used with number objects or literals 
1. toExponential(fractionDigits?) = returns string in exponential notation |return type is string
2. toFixed(fractionDigits?) = returns string with fixed decimals and rounded if needed |return type is string
3. toPrecision(precision?) = returns string with specified significant digits |return type is string
4. toLocaleString(locales?,options?) = returns locale specific string |return type is string
5. toString(radix?) = returns string representation in base 2-36. default 10 |return type is string
6. valueOf() = returns the primitive number value |return type is Number
note:: all string returning methods throw rangeError if digit params are invalid
       toLocalString is useful for internationalization

Type Coercion and conversion:
implicit coercion: JS auto converts in operation 
explicit coercion: Number("123") converts string into number
                 : Number(true) boolean to number
                 : Number(false) boolean to number
                 : Number(null) converts to 0
      edge cases
                 : Number("abc") invalid -> NaN
                 : Number('') -> 0
                 : Number(undefined) -> NaN
                 : 0/0->NaN
                 : 1/0->Infinity
                 : NaN !== NaN    it is not equal to itself
                 : 0==false is true so avoid == and use ===











